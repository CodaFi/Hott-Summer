{-# OPTIONS --without-K #-}
module Methods.Notes where

open import Agda.Primitive using (Level; _âŠ”_)

-- ========================
-- Day One (7 August, 2019)
-- ========================

-- Cubical Methods
-- ===============

{-
  The main motivation of cubical type and cubical set models is to give
  structure to homotopy type models.

  Assuming a universe of types U

     Î“ âŠ¢ A : U  Î“ âŠ¢ B : U
  ---------------------------- (Univalence)
  Î“ âŠ¢ UA : (A â‰ƒ B) â‰ƒ (Idáµ¤ A B)

  Adding this constant opens a question: How do we compute with this?

  This is the "constructivity problem" in HoTT.

  At first it wans't claer how to do this . But the simplicial set model from
  last lecture relies on set theory.

  If we start with Coq or Agda, this automatically makes them languages where
  the compiler doesn't actually know how to compile and run your programs.

  This was more-or-less solved by so-called "Cubical Methods" introduced by
  Coquand in '13.'
-}

open import Agda.Builtin.Sigma public
  renaming (fst to projâ‚; snd to projâ‚‚)
  hiding (module Î£)

module Î£ = Agda.Builtin.Sigma.Î£
  renaming (fst to projâ‚; snd to projâ‚‚)

infix 2 Î£-syntax

Î£-syntax : âˆ€ {a b}(A : Set a) â†’ (A â†’ Set b) â†’ Set (a âŠ” b)
Î£-syntax = Î£

syntax Î£-syntax A (Î» x â†’ B) = Î£[ x âˆˆ A ] B

data _â‰¡_ {a}{A : Set a}(x : A) : A â†’ Set a where
  refl : x â‰¡ x
{-# BUILTIN EQUALITY _â‰¡_ #-}


ind= : âˆ€ {i} {A : Set i} â†’ (C : (x y : A) â†’ (x â‰¡ y) â†’ Set i) â†’ ((x : A) â†’ C x x refl) â†’ {x y : A} â†’ (p : x â‰¡ y) â†’ C x y p
ind= C c {x}{y} p rewrite p = c y

-- For any A and B, a quasi-inverse of f is a triple with
--    âˆ˜ A way back (an inverse for the homomorphism)
--    âˆ˜ Homotopies:
--        âŠš Î± : f âˆ˜ g âˆ¼ id
--        âŠš Î² : g âˆ˜ f âˆ¼ id
-- For now, because I am lazy, the presence of a quasi-inverse will count
-- as our definition of equivalence for now.  Sorry.
record IsEquiv {i j}{A : Set i}{B : Set j}(to : A â†’ B) : Set (i âŠ” j) where
  field
    from : B â†’ A
    isoâ‚ : (x : A) â†’ from (to x) â‰¡ x
    isoâ‚‚ : (y : B) â†’ to (from y) â‰¡ y

-- Type equivalence is also an equivalence, just on the Universe because:
--    âˆ˜ id-is-equiv works for it, therefore A â‰ƒ A
--    âˆ˜ With A â‰ƒ B, we can always make B â‰ƒ A
--    âˆ˜ With A â‰ƒ B and B â‰ƒ C we have A â‰ƒ C
_â‰ƒ_ : âˆ€ {i j} (A : Set i) (B : Set j) â†’ Set (i âŠ” j)
A â‰ƒ B = Î£ (A â†’ B) IsEquiv

postulate
  ua : âˆ€ {i} {{A : Set i}}{{B : Set i}} â†’ (A â‰ƒ B) â‰ƒ (A â‰¡ B)
-- ^This says "equivalent types may be identified"

-- Cubical Implementations
-- =======================

{-
  - Cubical Agda
  - redtt
  - cubicaltt
-}

-- Cubical Type Theory
-- =======================

{-
  To MLTT, we add the interval type ğ•€ with endpoints 0ğ•€ and 1ğ•€

    - Note: The interval is a "Representable 1-Cube"

  - Intuition: ğ•€ is [0, 1] âŠ† â„

                 â†‘
  0ğ•€-------------x---------------> 1ğ•€

  We also allow extending contexts by interval terms.

  iâ‚ : ğ•š, ..., iâ‚™ : ğ•€ âŠ¢ A : U

  Example:

  âŠ¢ A : U
                               ---------- U
                              |          |
                              |    A     |
                              |          |
                               ----------

  Example:

  i : ğ•€ âŠ¢ A : U
                              ----------- U
                             |            |
                             | A(0)  A(2) |
                             |     \/     |
                             |    A(1)    |
                              ------------
  Example:

  i : ğ•€, j : ğ•€ âŠ¢ A : U

                                 A(i, 1)
                              ----------- U
                             |            |
                     A(0, j) | A(0)  A(2) | A(1, j)
                             |     \/     |
                             |    A(1)    |
                              ------------
                                 A(i, 0)

-}

-- The dependently typed version of `ap` takes a type family and relates its instantiations with p
transport : âˆ€ {i} {A : Set i}{P : A â†’ Set i}{x y : A} â†’ (p : x â‰¡ y) â†’ (P x â†’ P y)
transport {i} {A}{P} {x}{y} p = ind= D d p where
    D : (x y : A) â†’ (p : x â‰¡ y) â†’ Set i
    D x y p = P x â†’ P y

    d : (x : A) â†’ D x x refl
    d = Î» x â†’ (Î» y â†’ y)

-- The interval, which we denote I, is perhaps an even simpler higher inductive type than the
-- circle generated by:
module Interval where
  private
    data #I : Set where
      #0 : #I
      #1 : #I

  I : Set
  I = #I

  -- A point 0áµ¢
  0áµ¢ : I
  0áµ¢ = #0

  -- A point 1â‚
  1áµ¢ : I
  1áµ¢ = #1

  postulate -- A path segment
    path-seg : 0áµ¢ â‰¡ 1áµ¢

  -- "The recursion principle for the interval says that given a type B along with
  interval-rec : âˆ€ {b} {B : Set b} â†’
                       (bâ‚€ bâ‚ : B) â†’ -- points bâ‚€, bâ‚ and
                       (p : bâ‚€ â‰¡ bâ‚) â†’ -- a path bâ‚€ â‰¡ bâ‚
                       (i : I) â†’ B -- there is a function f : I â†’ B such that
  interval-rec bâ‚€ bâ‚ p #0 = bâ‚€ -- f(0áµ¢) â‰¡ bâ‚€
  interval-rec bâ‚€ bâ‚ p #1 = bâ‚ -- f(1áµ¢) â‰¡ bâ‚"

  -- The induction principle says that given P : I â†’ U along with
  interval-ind : âˆ€ {b} (P : I â†’ Set b)
                       (bâ‚€ : P 0áµ¢) â†’ -- a point bâ‚€ : P(0áµ¢)
                       (bâ‚ : P 1áµ¢) â†’ -- a point bâ‚ : P(1áµ¢) and
                       (p : transport {_}{_}{I}{P} path-seg bâ‚€ â‰¡ bâ‚) â†’
                       âˆ€ i â†’ P i -- there is a function f : Î (x:I) P(x) such that
  interval-ind P bâ‚€ bâ‚ p #0 = bâ‚€ -- f(0áµ¢) â‰¡ bâ‚€
  interval-ind P bâ‚€ bâ‚ p #1 = bâ‚ -- f(1áµ¢) â‰¡ bâ‚"
open Interval public

-- Cubical Set Models
-- ==================

{-
  For C a category of cubes (definition later), a Cubical Set is a presheaf on
  this category

    Äˆ = [Cáµ’áµ–, Set] = Fun(Cáµ’áµ–, Set)

  âŸ¦ Î“ âŸ§ is a "cubical set"

  Substitution:

  âŸ¦ Ïƒ : Î” â†’ Î“ âŸ§ is a natural transformation from âŸ¦Î”âŸ§ â†’ âŸ¦Î“âŸ§

  See Hoffman for the gritty details.
-}

-- Steve Awodey's Favorite Cubical Category
-- ========================================

{-
  The Cartesian Cube Category â–¡ is given by the following data:
    âˆ˜ Ob(â–¡)      = Finite Sets
    âˆ˜ Homâ–¡(A, B) = B â†’ A âŠ {0, 1}
      where I = { iâ‚, ..., iâ‚™ } called the "dimensions"

  NB: The morphisms are flipped - the cubical construction will flip them again.

  Notable Morphisms:
    âˆ˜ Face Maps: Given a dimension i, a finite set I:

        dâ‚€â± âˆˆ Homâ–¡(I, I + {i})
                 | 0 if i = j
        dâ‚€â±(j) = |
                 | j else

    âˆ˜ Degeneracy Maps:

      Sâ± âˆˆ Homâ–¡(I + {i}, I)
      Sâ±(j) = j

      "It takes a line and turns it into a square, a cube in n-D and makes it a
      cube in n+1-D, etc."

    âˆ˜ Symmetry Maps:

      "Swaps two dimenisons i and j"

    âˆ˜ Diagonal Maps:

      Dâ±Ê² âˆˆ Homâ–¡(I + {i}, I + {i, j})
               | i if k = 1 or k = j
      Dâ±Ê²(k) = |
               | k otherwise

      "Collapse dimensions i and j"
-}

{-

  A Cartesian Cubical Set Î“ is just an element of the presheaf Ì‚â–¡.

    Idea: Î“ is a space - Î“({iâ‚, ..., iâ‚™}) â‰ˆ [0, 1]â¿ â†’ Î“

  Example:
    Î“(dâ±â‚€) : Î“(I + {i}, I)

                    s
               ----------- U
              |            |     âˆ˜------------âˆ˜ p
            r |            | q â†¦ âˆ˜------------âˆ˜ q
              |            |     âˆ˜------------âˆ˜ r
              |            |     âˆ˜------------âˆ˜ s
              a ---------- b
                    p
                                 a ----------- b
                   p             ||            ||
             a ---------- b  â†¦   ||            ||
                                 ||            ||
                                 ||            ||
                                 a ----------- b
                                       p

  Example: Symmetry Map:

                   q                     s
             b ---------- c        ------------
             |            |       |            |
           p |            | s â†¦ r |            | q
             |            |       |            |
             |            |       |            |
             a ---------- d        -----------
                   r                    p

  âŸ¦ğ•€âŸ§ is interpreted by yoneda({i}) - y : â–¡ â†’ Ì‚â–¡

  NB: Anders is going to write ğ•€ for y({i}).  I'm going to try to expand them...
-}


-- Cubical Facts
-- =============

{-
  Fact: Products of representable cubes are again representable.  Note that this
  is not necessarily true everywhere!  Products of simplices require more
  structure to behave like this.  We get it for free with cubes!

  Fact: Y preserves products:
        y({iâ‚} Ã— ... Ã— {in}) â‰ƒ ğ•€â¿
    By Yoneda, there is a bijection between the n-cubes of Î“ and the natural
    transformations ğ•€â¿ â†’ Î“.

    - Topological intuition: The action of Î“ on a finite sense is verified by
      all this Abstract Nonsense.
-}

-- Back to Cubical Type Theory
-- ===========================

{-
  iâ‚ : ğ•€, ..., in : ğ•€ âŠ¢ A : U â‰ˆ A : ğ•€â¿ â†’ U

  Rules like the following "interval weakening" rule

      Î“ âŠ¢ A : U
  ---------------- (weak)
  Î“, i : ğ•€ âŠ¢ A : U

  Fall out of the cubical structure.  Semantically, this
  appears in the cube category as morphisms.

                 y(Sâ€²)
    y(I + {i}) --------â†’ y(I)

  Exchange corresponds to the symmetry maps

  Contraction corresponds to the diagonal maps
-}

-- Path Types
-- ==========

{-
  So we've added intervals, but we can't access the data contained in the
  interval.  To do that, let's see paths

  Formation:

      Î“ , i : ğ•€ âŠ¢ A     Î“ âŠ¢ a : A(0 / i)   Î“ âŠ¢ b : A(1 / i)
    ----------------------------------------------------------
                  Î“ âŠ¢ Pathâ±(A, a, b) type

    "Given a line and two endpoints on the line, we can form the type of paths
     between the endpoints.  Moreover, we just do it like lambda abstraction."

            a                                                   b
                                Pathâ±(A, a, b)
     A(0/i) âˆ˜ ------------------------------------------------- âˆ˜ A(1/i)

  Introduction:

           Î“ , i : ğ•€ âŠ¢ A     Î“ , i : ğ•€ âŠ¢ a : A
    ------------------------------------------------
      Î“ âŠ¢ Î» (i : ğ•€) . a : Pathâ±(A, a(0/i), a(1.i))

  Elmination:

         Î“ âŠ¢ p : Pathâ±(A, a, b)   Î“ âŠ¢ r : ğ•€
    -------------------------------------------
              Î“ âŠ¢ p r : A(r / i)

  Computation:

    - Beta reduction
    - p(0) = a
    - p(1) = b

  Uniqueness: Î·
-}

-- Examples
-- =========

{-
  Reflexivity is just the constant path

    refl : (a : A) â†’ Path(A, a, a)
    refl a = Î» (i : ğ•€) â†’ a

  Recall:

    data _â‰¡_ {a}{A : Set a}(x : A) : A â†’ Set a where
      refl : x â‰¡ x
-}

{-
  HoTT book calls this one ap
-}

{-
  Non-cubical:
-}

ap : âˆ€ {i j} {A : Set i}{B : Set j}{x y : A}{f : A â†’ B} â†’ (x â‰¡ y) â†’ (f x â‰¡ f y)
ap {i}{j} {A}{B} {x}{y}{f} p = ind= D d p where
  D : (x y : A) â†’ (p : x â‰¡ y) â†’ Set j
  D x y p = f x â‰¡ f y

  d : (x : A) â†’ D x x refl
  d = Î» x â†’ refl

{-
  Cubical:
    ap : (a b : A)(f : A â†’ B)(p : Path A a b) â†’ Path B (f a) (f b)
    ap a b f p := Î» (i : ğ•€) â†’ f (p i)
-}

{-
  Extensionality

  Non-cubical:

    postulate
      extensionality : âˆ€ {a b} {A : Set a} {B : A â†’ Set b} (f g : (a : A) â†’ B a) â†’ (âˆ€ x â†’ f x â‰¡ g x) â†’ f â‰¡ g

  Cubical:

    funext : (f h : A â†’ B)(p : (x : A) â†’ Path B (f x) (g x)) â†’ Path (A â†’ B) f g
    funext f g p := Î» (i : ğ•€) : Î» (x A) â†’ (p x) i

-}

funext : âˆ€ {a b}{A : Set a}{B : A â†’ Set b}{f g : (x : A) â†’ B x} â†’ (âˆ€ x â†’ f x â‰¡ g x) â†’ f â‰¡ g
funext {A = A}{B = B} {f = f}{g = g} p = ap {f = h} path-seg
  where
    h : I â†’ (x : A) â†’ B x
    h i x = interval-rec (f x) (g x) (p x) i
{-
  This works:

    funext f g p 0 â‰¡ Î» (x : A) â†’ (p x) 0 â‰¡ Î» (x : A) â†’ f x â‰¡ f

  "It just swaps a term variable for a path variable."
-}












--
