{-# OPTIONS --without-K #-}
module Methods.Notes where

open import Agda.Primitive using (Level; _⊔_)

-- ========================
-- Day One (7 August, 2019)
-- ========================

-- Cubical Methods
-- ===============

{-
  The main motivation of cubical type and cubical set models is to give
  structure to homotopy type models.

  Assuming a universe of types U

     Γ ⊢ A : U  Γ ⊢ B : U
  ---------------------------- (Univalence)
  Γ ⊢ UA : (A ≃ B) ≃ (Idᵤ A B)

  Adding this constant opens a question: How do we compute with this?

  This is the "constructivity problem" in HoTT.

  At first it wans't claer how to do this . But the simplicial set model from
  last lecture relies on set theory.

  If we start with Coq or Agda, this automatically makes them languages where
  the compiler doesn't actually know how to compile and run your programs.

  This was more-or-less solved by so-called "Cubical Methods" introduced by
  Coquand in '13.'
-}

open import Agda.Builtin.Sigma public
  renaming (fst to proj₁; snd to proj₂)
  hiding (module Σ)

module Σ = Agda.Builtin.Sigma.Σ
  renaming (fst to proj₁; snd to proj₂)

infix 2 Σ-syntax

Σ-syntax : ∀ {a b}(A : Set a) → (A → Set b) → Set (a ⊔ b)
Σ-syntax = Σ

syntax Σ-syntax A (λ x → B) = Σ[ x ∈ A ] B

data _≡_ {a}{A : Set a}(x : A) : A → Set a where
  refl : x ≡ x
{-# BUILTIN EQUALITY _≡_ #-}


ind= : ∀ {i} {A : Set i} → (C : (x y : A) → (x ≡ y) → Set i) → ((x : A) → C x x refl) → {x y : A} → (p : x ≡ y) → C x y p
ind= C c {x}{y} p rewrite p = c y

-- For any A and B, a quasi-inverse of f is a triple with
--    ∘ A way back (an inverse for the homomorphism)
--    ∘ Homotopies:
--        ⊚ α : f ∘ g ∼ id
--        ⊚ β : g ∘ f ∼ id
-- For now, because I am lazy, the presence of a quasi-inverse will count
-- as our definition of equivalence for now.  Sorry.
record IsEquiv {i j}{A : Set i}{B : Set j}(to : A → B) : Set (i ⊔ j) where
  field
    from : B → A
    iso₁ : (x : A) → from (to x) ≡ x
    iso₂ : (y : B) → to (from y) ≡ y

-- Type equivalence is also an equivalence, just on the Universe because:
--    ∘ id-is-equiv works for it, therefore A ≃ A
--    ∘ With A ≃ B, we can always make B ≃ A
--    ∘ With A ≃ B and B ≃ C we have A ≃ C
_≃_ : ∀ {i j} (A : Set i) (B : Set j) → Set (i ⊔ j)
A ≃ B = Σ (A → B) IsEquiv

postulate
  ua : ∀ {i} {{A : Set i}}{{B : Set i}} → (A ≃ B) ≃ (A ≡ B)
-- ^This says "equivalent types may be identified"

-- Cubical Implementations
-- =======================

{-
  - Cubical Agda
  - redtt
  - cubicaltt
-}

-- Cubical Type Theory
-- =======================

{-
  To MLTT, we add the interval type 𝕀 with endpoints 0𝕀 and 1𝕀

    - Note: The interval is a "Representable 1-Cube"

  - Intuition: 𝕀 is [0, 1] ⊆ ℝ

                 ↑
  0𝕀-------------x---------------> 1𝕀

  We also allow extending contexts by interval terms.

  i₁ : 𝕚, ..., iₙ : 𝕀 ⊢ A : U

  Example:

  ⊢ A : U
                               ---------- U
                              |          |
                              |    A     |
                              |          |
                               ----------

  Example:

  i : 𝕀 ⊢ A : U
                              ----------- U
                             |            |
                             | A(0)  A(2) |
                             |     \/     |
                             |    A(1)    |
                              ------------
  Example:

  i : 𝕀, j : 𝕀 ⊢ A : U

                                 A(i, 1)
                              ----------- U
                             |            |
                     A(0, j) | A(0)  A(2) | A(1, j)
                             |     \/     |
                             |    A(1)    |
                              ------------
                                 A(i, 0)

-}

-- The dependently typed version of `ap` takes a type family and relates its instantiations with p
transport : ∀ {i} {A : Set i}{P : A → Set i}{x y : A} → (p : x ≡ y) → (P x → P y)
transport {i} {A}{P} {x}{y} p = ind= D d p where
    D : (x y : A) → (p : x ≡ y) → Set i
    D x y p = P x → P y

    d : (x : A) → D x x refl
    d = λ x → (λ y → y)

-- The interval, which we denote I, is perhaps an even simpler higher inductive type than the
-- circle generated by:
module Interval where
  private
    data #I : Set where
      #0 : #I
      #1 : #I

  I : Set
  I = #I

  -- A point 0ᵢ
  0ᵢ : I
  0ᵢ = #0

  -- A point 1₁
  1ᵢ : I
  1ᵢ = #1

  postulate -- A path segment
    path-seg : 0ᵢ ≡ 1ᵢ

  -- "The recursion principle for the interval says that given a type B along with
  interval-rec : ∀ {b} {B : Set b} →
                       (b₀ b₁ : B) → -- points b₀, b₁ and
                       (p : b₀ ≡ b₁) → -- a path b₀ ≡ b₁
                       (i : I) → B -- there is a function f : I → B such that
  interval-rec b₀ b₁ p #0 = b₀ -- f(0ᵢ) ≡ b₀
  interval-rec b₀ b₁ p #1 = b₁ -- f(1ᵢ) ≡ b₁"

  -- The induction principle says that given P : I → U along with
  interval-ind : ∀ {b} (P : I → Set b)
                       (b₀ : P 0ᵢ) → -- a point b₀ : P(0ᵢ)
                       (b₁ : P 1ᵢ) → -- a point b₁ : P(1ᵢ) and
                       (p : transport {_}{_}{I}{P} path-seg b₀ ≡ b₁) →
                       ∀ i → P i -- there is a function f : Π(x:I) P(x) such that
  interval-ind P b₀ b₁ p #0 = b₀ -- f(0ᵢ) ≡ b₀
  interval-ind P b₀ b₁ p #1 = b₁ -- f(1ᵢ) ≡ b₁"
open Interval public

-- Cubical Set Models
-- ==================

{-
  For C a category of cubes (definition later), a Cubical Set is a presheaf on
  this category

    Ĉ = [Cᵒᵖ, Set] = Fun(Cᵒᵖ, Set)

  ⟦ Γ ⟧ is a "cubical set"

  Substitution:

  ⟦ σ : Δ → Γ ⟧ is a natural transformation from ⟦Δ⟧ → ⟦Γ⟧

  See Hoffman for the gritty details.
-}

-- Steve Awodey's Favorite Cubical Category
-- ========================================

{-
  The Cartesian Cube Category □ is given by the following data:
    ∘ Ob(□)      = Finite Sets
    ∘ Hom□(A, B) = B → A ⊎ {0, 1}
      where I = { i₁, ..., iₙ } called the "dimensions"

  NB: The morphisms are flipped - the cubical construction will flip them again.

  Notable Morphisms:
    ∘ Face Maps: Given a dimension i, a finite set I:

        d₀ⁱ ∈ Hom□(I, I + {i})
                 | 0 if i = j
        d₀ⁱ(j) = |
                 | j else

    ∘ Degeneracy Maps:

      Sⁱ ∈ Hom□(I + {i}, I)
      Sⁱ(j) = j

      "It takes a line and turns it into a square, a cube in n-D and makes it a
      cube in n+1-D, etc."

    ∘ Symmetry Maps:

      "Swaps two dimenisons i and j"

    ∘ Diagonal Maps:

      Dⁱʲ ∈ Hom□(I + {i}, I + {i, j})
               | i if k = 1 or k = j
      Dⁱʲ(k) = |
               | k otherwise

      "Collapse dimensions i and j"
-}

{-

  A Cartesian Cubical Set Γ is just an element of the presheaf ̂□.

    Idea: Γ is a space - Γ({i₁, ..., iₙ}) ≈ [0, 1]ⁿ → Γ

  Example:
    Γ(dⁱ₀) : Γ(I + {i}, I)

                    s
               ----------- U
              |            |     ∘------------∘ p
            r |            | q ↦ ∘------------∘ q
              |            |     ∘------------∘ r
              |            |     ∘------------∘ s
              a ---------- b
                    p
                                 a ----------- b
                   p             ||            ||
             a ---------- b  ↦   ||            ||
                                 ||            ||
                                 ||            ||
                                 a ----------- b
                                       p

  Example: Symmetry Map:

                   q                     s
             b ---------- c        ------------
             |            |       |            |
           p |            | s ↦ r |            | q
             |            |       |            |
             |            |       |            |
             a ---------- d        -----------
                   r                    p

  ⟦𝕀⟧ is interpreted by yoneda({i}) - y : □ → ̂□

  NB: Anders is going to write 𝕀 for y({i}).  I'm going to try to expand them...
-}


-- Cubical Facts
-- =============

{-
  Fact: Products of representable cubes are again representable.  Note that this
  is not necessarily true everywhere!  Products of simplices require more
  structure to behave like this.  We get it for free with cubes!

  Fact: Y preserves products:
        y({i₁} × ... × {in}) ≃ 𝕀ⁿ
    By Yoneda, there is a bijection between the n-cubes of Γ and the natural
    transformations 𝕀ⁿ → Γ.

    - Topological intuition: The action of Γ on a finite sense is verified by
      all this Abstract Nonsense.
-}

-- Back to Cubical Type Theory
-- ===========================

{-
  i₁ : 𝕀, ..., in : 𝕀 ⊢ A : U ≈ A : 𝕀ⁿ → U

  Rules like the following "interval weakening" rule

      Γ ⊢ A : U
  ---------------- (weak)
  Γ, i : 𝕀 ⊢ A : U

  Fall out of the cubical structure.  Semantically, this
  appears in the cube category as morphisms.

                 y(S′)
    y(I + {i}) --------→ y(I)

  Exchange corresponds to the symmetry maps

  Contraction corresponds to the diagonal maps
-}

-- Path Types
-- ==========

{-
  So we've added intervals, but we can't access the data contained in the
  interval.  To do that, let's see paths

  Formation:

      Γ , i : 𝕀 ⊢ A     Γ ⊢ a : A(0 / i)   Γ ⊢ b : A(1 / i)
    ----------------------------------------------------------
                  Γ ⊢ Pathⁱ(A, a, b) type

    "Given a line and two endpoints on the line, we can form the type of paths
     between the endpoints.  Moreover, we just do it like lambda abstraction."

            a                                                   b
                                Pathⁱ(A, a, b)
     A(0/i) ∘ ------------------------------------------------- ∘ A(1/i)

  Introduction:

           Γ , i : 𝕀 ⊢ A     Γ , i : 𝕀 ⊢ a : A
    ------------------------------------------------
      Γ ⊢ λ (i : 𝕀) . a : Pathⁱ(A, a(0/i), a(1.i))

  Elmination:

         Γ ⊢ p : Pathⁱ(A, a, b)   Γ ⊢ r : 𝕀
    -------------------------------------------
              Γ ⊢ p r : A(r / i)

  Computation:

    - Beta reduction
    - p(0) = a
    - p(1) = b

  Uniqueness: η
-}

-- Examples
-- =========

{-
  Reflexivity is just the constant path

    refl : (a : A) → Path(A, a, a)
    refl a = λ (i : 𝕀) → a

  Recall:

    data _≡_ {a}{A : Set a}(x : A) : A → Set a where
      refl : x ≡ x
-}

{-
  HoTT book calls this one ap
-}

{-
  Non-cubical:
-}

ap : ∀ {i j} {A : Set i}{B : Set j}{x y : A}{f : A → B} → (x ≡ y) → (f x ≡ f y)
ap {i}{j} {A}{B} {x}{y}{f} p = ind= D d p where
  D : (x y : A) → (p : x ≡ y) → Set j
  D x y p = f x ≡ f y

  d : (x : A) → D x x refl
  d = λ x → refl

{-
  Cubical:
    ap : (a b : A)(f : A → B)(p : Path A a b) → Path B (f a) (f b)
    ap a b f p := λ (i : 𝕀) → f (p i)
-}

{-
  Extensionality

  Non-cubical:

    postulate
      extensionality : ∀ {a b} {A : Set a} {B : A → Set b} (f g : (a : A) → B a) → (∀ x → f x ≡ g x) → f ≡ g

  Cubical:

    funext : (f h : A → B)(p : (x : A) → Path B (f x) (g x)) → Path (A → B) f g
    funext f g p := λ (i : 𝕀) : λ (x A) → (p x) i

-}

funext : ∀ {a b}{A : Set a}{B : A → Set b}{f g : (x : A) → B x} → (∀ x → f x ≡ g x) → f ≡ g
funext {A = A}{B = B} {f = f}{g = g} p = ap {f = h} path-seg
  where
    h : I → (x : A) → B x
    h i x = interval-rec (f x) (g x) (p x) i
{-
  This works:

    funext f g p 0 ≡ λ (x : A) → (p x) 0 ≡ λ (x : A) → f x ≡ f

  "It just swaps a term variable for a path variable."
-}












--
